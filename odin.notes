init random
	import "core:time"
	import "core:math/rand"
	rand.set_global_seed(auto_cast time.now()._nsec)

random in range
	rand.uint32() % range

memory arena
  make_arena :: proc(size: int) -> mem.Allocator {
    memory, err := mem.alloc_bytes(size)
    if err != nil {
      log.fatal("Unable to allocate arena memory:", err)
    }
    a := new(mem.Arena)
    mem.init_arena(a, memory)
    return mem.arena_allocator(a)
  }

  arena := make_arena(mem.megabytes(10))

temp arena memory
	temp_memory := mem.begin_arena_temp_memory(&arena)
	mem.end_arena_temp_memory(temp_memory)

SOA
	v_soa := make_soa(#soa[dynamic]int, SIZE)
	append_soa(&v_soa, int)

open file
	fd, err := os.open(FILENAME, os.O_RDONLY, 0)
	assert(err == os.ERROR_NONE)

read full file
	buf: [256]byte
	read := 1
	for read > 0 { // EOF
		err: os.Errno
		read, err = os.read(fd, buf[:])
		assert(err == os.ERROR_NONE)
	}

read lines
	r: bufio.Reader
	bufio.reader_init(&r, io.to_reader(os.stream_from_handle(fd)))
	defer bufio.reader_destroy(&r)
	b, err := bufio.reader_read_slice(&r, '\n')
	assert(err == .None)
	line := string(b)
	trimmed := strings.trim_space(line)

get string size in bytes
	str := "Hello, 世界!"
	len(str)

get string size in runes
	utf8.rune_count_in_string(str)

iterate over bytes in string
	for i in 0..<len(str) {
		c := rune(str[i])
		fmt.println(i, c)
	}

iterate over runes in string
	for c, i in str {
		fmt.println(i, c)
	}
